<h3>Haskell的类型系统</h3>

<p>在开始看Haskell的类型系统前，我们先看一下什么是类型以及类型系统。
引自Wikipedia:</p>

<blockquote>
  <p>在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，如何操作这些类型，这些类型如何互相作用。类型可以确认一个值或者一组值具有特定的意义和目的（虽然某些类型，如抽象类型和函数类型，在程序运行中，可能不表示为值）。类型系统在各种语言之间有非常大的不同，也许，最主要的差异存在于编译时期的语法，以及运行时期的操作实现方式。</p>
</blockquote>

<p>类型系统定义了一系列类型，类型之间的关系，在这些类型上的操作，这些都属于语言编译与执行时语义级别的约束与规则。类型的关系以及操作分为逻辑层面与物理层面，逻辑层面就是上面提到的约束与操作规则，类似于数据结构的逻辑结构；而在物理层面，一个类型在内存中存储结构，运行时期的实现等因素。</p>

<p>在前面一篇提到了Haskell是一种静态类型的语言。在物理层面上（机器）是不存在类型的，一切的数据就是0与1，对于某些虚拟机编译成为的中间语言包含了一些初等类型操作(Primitive Type Operation)，例如 IntAdd、FloatAdd之类的，但是这些都是作为最后进行解释执行时的标记，与接下来讲到的静态类型编译是类似的。物理存储是由逻辑结构决定的，一种类型在实现时由于编程语言的偏向可能会有所不同，但是在某种编程语言实现下，类型的物理实现是确定的。</p>

<p>编译原理中除了解析，语法树的建立，转译成目标机器语言之外，很重要的一块是进行程序优化。在语义不变的情况下，如何实现代码优化，从而提升性能，达到系统非功能属性需求，这是很重要的一块。硬件的速度早就很惊人了，瓶颈在于如何优化系统的执行效率（系统越来越复杂，兼容原有系统或者新的硬件都给这一领域带来巨大挑战）。而对于编译优化中很重要的就是对于一些无依赖性的代码进行合理地重组，或者转述，（虽然优化重组可能会给我们带来不少麻烦..比如某些情况下，代码的执行不像我们所预期的，还有一些对于内存栅栏与并发的问题）很多这些工作需要对源代码进行不只一次地分析以及优化，对于许多解释性语言在解释执行的过程中对于全局的优化，语句重组以及反复分析扫描是很有难度的。在语言类型上有种分类是静态类型以及动态类型，静态类型是在系统编译时期就确定所使用的数据类型，这样的好处有若干：</p>

<ul>
<li><p>安全性，利用确定的类型信息，很多程序可能潜在的问题（类型不匹配带来的操作错误，程序崩溃，排错）等等能够通过一套类型推理（对于类型上以及类型间的操作约束检查）以及诊断机制暴露出来，程序运行的安全性以及可靠性才有保证</p></li>
<li><p>优化，编译器知道的信息越多，就能够更有针对性地进行代码优化，优化存储结构，语句执行顺序等</p></li>
</ul>

<p>而对于动态类型，需要将以上的一些检查带入运行时才能发现问题，甚至导致程序崩溃，对于耗时地编译而言，在硬件如此给力的今天，性能在某些情况下已经不是首要考虑的了，人们更关注开发大型系统时的模块可管理性，可维护性；完成一些小任务时的表达效率等方面。一些动态解释型的语言正是在这样一些应用场景中，通过可交互性以及表达性带来的开发效率的提升而大放异彩。</p>

<p>Haskell属于函数编程ML系，其有着严格的类型系统以及操作性约束，这些保证了程序的正确性以及安全性，使得设计出的程序具备良好的可靠性保障。当然这里插一句，编程语言或者类型系统并不能对系统的质量起到决定性作用，软件的结构，设计者的设计决策以及实现上对于某些质量属性的权衡更是关键。</p>

<p>Haskell中，一切皆有对应的类型，同时也支持类型推导。这与传统的静态类型语言有所不同，例如Java中(尽管新版本的Java中有些地方加入了一定的类型推断)需要对声明的变量同时进行类型声明，降低代码可理解性也降低了开发效率。Haskell中的类型推断使得类型的声明被精简到了"只在必要时声明"。即便声明也没有错，帮助编译器完成类型提示，这在Clojure中甚至是程序性能优化的一种手段（实质还是减少了不确定信息，明确了优化方向）。</p>

<p>类型是程序语言中值或者元素的标签，通过这些标签我们可以确定元素的语义。GHCi下，可以用 :t 来检查类型。</p>

<pre><code>ghci &gt; :t 'M' # -&gt; 'M' :: Char
</code></pre>

<p>Char标识了其类型，'::'是指**属于类型X。如果检查元素为符合类型，比如Tuple，则会展开显示类型(由于Tuple支持多类型，因此对于Tuple的类型检查不得不展开，而List只允许同一类型的元素)。元素也包括了表达式，函数等，不仅仅是求值的类型。</p>

<p>尽管有类型推导，但是在进行一些比较大型项目开发的过程中，声明类型总是一个好的习惯.</p>

<p>Haskell中，函数的类型通常作为一个映射，例如 </p>

<blockquote>
  <p>Expression :: TypeA -> TypeB -> TypeC</p>
</blockquote>

<p>协程我们所认识的型构就是:</p>

<blockquote>
  <p>TypeC Fun(TypeA, TypeB)</p>
</blockquote>

<p>然而从直观来看，输入值为一个笛卡尔乘积更为直观，(TypeA, TypeB) -> TypeC. 那么在Haskell中为什么是“->”呢? 往后看。</p>

<p>Haskell中常见的类型:</p>

<ul>
<li><p>Int 一般对应于C中的int，上下界是机器相关的</p></li>
<li><p>Integer 相当于Big Integer，理论上无界</p></li>
<li><p>Float 单精度浮点数</p></li>
<li><p>Double 双精度浮点数</p></li>
<li><p>Bool 对应的值只有True以及False</p></li>
<li><p>Char 字符，而一个字符串为一个[Char]</p></li>
</ul>

<p>我比较赞同这样对待字符与字符串的关系，在某些语言中，例如Java，一个字符串与字符之间的关系非要通过toBytes之类的方法来变换，有的语言中干脆就没有字符了，都属于字符串对象，区分List和String的同时也有一些混淆的操作，比如某些脚本语言。</p>

<p>Haskell也支持多态，也就意味着能够对多种类型实现相同逻辑的一致性操作。例如:</p>

<pre><code>:t tail # -&gt; tail :: [a] -&gt; [a]
</code></pre>

<p>可以看做是tail函数接受一个List，返回另一个List，且两个List是同类型的。a在此处指的是类型变量，a可以指代任何一种类型，这也使得这样一个函数定义的借口实现了泛化，从而支持了多态。在Haskell中声明的多态函数是很有实际意义的。</p>

<p>多态是作用在类型上的，对于一系列不同类型提供一致性的接口或者操作。某些编程语言是通过类的继承，通过类的继承关系以及里氏替换原则来实现多态的正确应用，子类重写父类的行为，或者同一种行为有接受不同参数表现出不同的行为；这是以类为核心实现的行为上的多态，而另一种思路则是通过函数的型构来完成多态。支持这样的编程语言中能实现一些更为灵活的多态机制，比如鸭子类型（Duck Type）---- </p>

<blockquote>
  <p>"什么类型的不重要，是不是支持某些操作才重要".</p>
</blockquote>

<p>而还有一类多态就是类似Java的泛型类，或者C++中的模板一样, 通过对类型变量的泛化，实现多态，因此可以将上面例子中的tail函数看做是一个模板方法，接受一个T类型元素的数组，返回另一个T类型的元素数组。</p>

<p>在类型系统中，任何类都有自身属于的类型，类的类型是元类，在很多编程语言中，为了支持元编程，或者说具有内省的机制，一些语言引入了对于类型类以及相关操作。Python中的type，Java中的Class等等，Haskell也是如此。</p>

<p>在Haskell中，如果某类型属于某类型类，其需要实现类型类所描述的属性。例如，</p>

<pre><code>ghci &gt; :t (elem)
(elem) :: Eq a =&gt; a -&gt; [a] -&gt; Bool
</code></pre>

<p>其中“=&gt;”代表类型约束，也就是完成该函数动作的输入类a必须满足类型类Eq的定义。Eq类要求对于==以及/=，除了函数之外，一般类都具有Eq指定的方法，可以判断相等性。</p>

<p>列举一下基本的类型类：</p>

<ul>
<li><p>Eq 包含的类型必须可判断相等性</p></li>
<li><p>Ord 是Eq成员的子集，能够判断序关系</p></li>
<li><p>Show 成员为可使用字符串表示的对象，除函数外</p></li>
<li><p>Read Show的逆运算，可将字符串转化为某成员类型</p></li>
</ul>

<p>Read返回类型可以根据Type Ref获得，但是一般情况下最好对编译器进行类型提示，编译器需要在编译时期确认所有值的可能类型。和进行推理需要线索一样，编译器进行类型推断也需要通过该变量被使用的上下文来确定某个类型。所以，如果仅仅是：</p>

<pre><code>ghci &gt; read "5"
</code></pre>

<p>那么编译器是会报错的，由于此处没有通过read需要转化为的字符串内容的上下文的类型，这不是类型安全的做法，要么在需要读的地方必须与别的可以明确类型的配合使用，否则就应当：</p>

<pre><code>ghci &gt; read "5" :: Int
</code></pre>

<p>配合别的类型进行操作以配合类型推断，必须是确定的类型，如果：</p>

<pre><code>ghci &gt; (read "'a'"):[]
</code></pre>

<p>我们的意思是将一个字符'a'添加到一个字符串中，如果是(read "'a'"):['b'..'e']，那么没有问题，但是如果是上面那种情况，那么此时[]的类型为[a],a代表的类型目前是未确定的，因此编译器也会报错。</p>

<ul>
<li><p>Enum 符合该类型类描述的是可枚举的类，我们可以通过Range，Succ，Pred等对它们进行操作
<em>一般包含的类型有：(), Int, Char, Ordering, Float, Double, Integer</em></p></li>
<li><p>Bounded 成员必须有界。maxBound，minBound都是(Bound a ) =&gt; a, 对于复合类而言，如果子类都是Bound，那么其也是Bound</p></li>
<li><p>Num是数字的类型类，其都有数字特征，其包含了Integral以及Floating，其是Eq与Show成员的子集
<em>fromIntegral</em>的类型是</p>

<p>fromIntegral :: (Integral a, Num b) =&gt; a -> b</p></li>
</ul>

<p>因而对于整数与浮点数进行计算时，不会进行自动转型。此时需要做的是将整数泛化为Num类型，然后进行计算，有点绕。</p>

<p>类型系统的推理以及其与定理证明的关系是一门很深的学问，这里跳过，我们下面看Haskell的函数。</p>
