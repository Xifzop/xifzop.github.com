<!DOCTYPE html><html><head><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>On_Haskell</title></head><body><h2 id="haskell">学习Haskell</h2>
<hr />
<p>Haskell是一门纯函数式编程语言</p>
<p>简单地开始学习Haskell，需要的是最基本的交互式环境编程以及编译器的使用。这里我结合Sublime text 2的SublimeHaskell插件，完成最基本的配置。在学习过程中间，如果为了配置一些很少或者用不到的东西，我认为那样的时间花费总是不必要的。[有没有一点惰性求值的赶脚?]</p>
<p>Mac下通过</p>
<blockquote>
<p>sudo port install ghc</p>
</blockquote>
<p>就能完成Haskell编译器的下载，<a href="http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler">Glasgow Haskell Compiler</a>.</p>
<p>在终端下能够输入ghci的交互式编程。
一个简单的HelloWorld.hs</p>
<blockquote>
<p>main :: IO()</p>
<p>main = putStrLn "Hello, world!"
  # -&gt; Hello world!</p>
</blockquote>
<p>在Haskell中，由于其是纯函数式编程，因而其是引用透明的，也就是一个函数不会对某个变量产生副作用，而只要输入值不变，那么完成操作的返回的值也不变。</p>
<p>基本的数值型计算,</p>
<ul>
<li>
<p>+, -, *, /, ( % for mod does not exist ), mod</p>
</li>
<li>
<p>==, /= (not equal)</p>
</li>
</ul>
<p>Bool（True与False）的操作围绕 &amp;&amp; || 还有 not组合。</p>
<p>在Haskell编程中要求严格的操作符类型匹配，否则就会报错。例如，</p>
<blockquote>
<p>1 + "1"</p>
</blockquote>
<pre><code>interactive&gt;:12:1:

No instance for (Num Char) arising from the literal `1'
Possible fix: add an instance declaration for (Num Char)
In the first argument of `(==)', namely `1'
In the expression: 1 == '1'
In an equation for `it': it = 1 == '1'
</code></pre>
<p>其实在编程语言的语义分析以及程序正确性验证（并非一般所提及的测试，而是将程序的执行转化为定理证明，通过严密的数学逻辑进行推导）的过程当中，类型分析以及匹配是很关键的一块。这对于大部分非弱类型的语言来说，是很关键的。比如，利用Java编程的人总是在抱怨对于null的处理，很多别的编程语言中也是如此。在很多编程语言中空值或者空对象，总是被当作通用类型或者特殊值来处理。这简化了设计，但是也给程序正确性验证以及编译器进行类型推导、排错带来更大的难度。当然，也有编程语言采用另外一种设计思路，也就是迫使程序员在定义某一类型的同时，将该类型可能的形式进行一个枚举（比如nullType与非nullType），这样的话编译器在进行类型验证的过程当中就可以进行一个模式匹配，或者说类型定义的匹配，而程序员在处理某一类型的一般性代码时，编译器会要求程序员同时处理可能潜在的case。这样的程序正确性能够得到保证的同时，也利于错误的排查。但是目前的通用语言里面这样的不多，比如OCaml这一类的ML函数式编程语言。以及Haskell。</p>
<p>一般通过let或者直接赋值的方式定义一个常量，没有给出类型提示时Haskell会自动进行类型推导。</p>
<p>先看看递增函数succ。</p>
<blockquote>
<p>succ 2 # -&gt; 3</p>
<p>min 2 3 # -&gt; 2</p>
<p>max 2 3 # -&gt; 3</p>
</blockquote>
<p>Haskell中简单定义函数，
函数名字(首字母不能大写，可以有')与函数体：</p>
<blockquote>
<p>doubleTimes x = x + x
doubleTimes 2 # -&gt; 4</p>
</blockquote>
<p>也可以采用 if-then-else的结构。</p>
<p>与许多函数式语言一样，为了对数据有统一性的结构化操作，在Haskell中通用数据类型是List ---- &lt;表&gt;.</p>
<p>List的通用操作:</p>
<pre><code>list1 ++ list2

element : list3
</code></pre>
<p>对于List而言，++意味着对于前面的列表进行一个遍历，如果插入短字符串，那么通过第二种方式加入新元素将会是更好的选择，字符串也类似于List。例如：</p>
<pre><code>"foo bar ... n" ++ "here"
</code></pre>
<p>等价于</p>
<pre><code>'f':'o':'o':....:"here"
</code></pre>
<p>最后一个必须是一个List结构。</p>
<p>正如之前提到的，List在定义的过程当中，是递归定义的(以下是简写，了解巴库斯范式的应该不能理解)。</p>
<pre><code>List :=  []
        | element:List
</code></pre>
<p>通过!!符号取得某一索引处的值。例如，</p>
<pre><code>[6,4,7,2,3,8] !! 3 # -&gt; 2
</code></pre>
<p>head返回一个List的头部，也就是List的首个元素。</p>
<blockquote>
<p>ghci&gt; head [5,4,3,2,1]<br />
5</p>
</blockquote>
<p>tail返回一个LIst的尾部，也就是List除去头部之后的部分。</p>
<blockquote>
<p>ghci&gt; tail [5,4,3,2,1] <br />
[4,3,2,1]  </p>
</blockquote>
<p>last返回一个LIst的最后一个元素。</p>
<blockquote>
<p>ghci&gt; last [5,4,3,2,1] <br />
1  </p>
</blockquote>
<p>init返回一个LIst出去最后一个元素的部分。</p>
<blockquote>
<p>ghci&gt; init [5,4,3,2,1] <br />
[5,4,3,2]  </p>
</blockquote>
<p>从空List需要谨慎。</p>
<p>length返回一个List的长度。</p>
<blockquote>
<p>ghci&gt; length [5,4,3,2,1] <br />
5 </p>
</blockquote>
<p>null检查一个List是否为空。如果是，则返回True，否则返回False。应当避免使用xs==[]之类的语句来判断List是否为空，使用null会更好。</p>
<blockquote>
<p>ghci&gt; null [1,2,3] <br />
False <br />
ghci&gt; null [] <br />
True </p>
</blockquote>
<p>reverse将一个List反转</p>
<blockquote>
<p>ghci&gt; reverse [5,4,3,2,1] <br />
[1,2,3,4,5] </p>
</blockquote>
<p>take返回一个List的前几个元素，看：</p>
<blockquote>
<p>ghci&gt; take 3 [5,4,3,2,1] <br />
[5,4,3] <br />
ghci&gt; take 1 [3,9,3] <br />
[3] <br />
ghci&gt; take 5 [1,2] <br />
[1,2]   </p>
</blockquote>
<p>drop和take作用类似，但是drop有点不一样，返回的是被删除之后的几个元素的列表。</p>
<p>maximum返回一个List中最大的那个元素。miniimun返回最小的。</p>
<blockquote>
<p>ghci&gt; minimum [8,4,2,1,5,6] <br />
1 <br />
ghci&gt; maximum [1,9,2,3,4] <br />
9</p>
</blockquote>
<p>sum返回一个List中所有元素的和。product返回一个List中所有元素的积。</p>
<blockquote>
<p>ghci&gt; sum [5,2,1,6,3,2,5,7] <br />
31 <br />
ghci&gt; product [6,2,1,2] <br />
24 <br />
ghci&gt; product [1,2,5,6,7,9,2,0] <br />
0  </p>
</blockquote>
<p>elem判断一个元素是否在包含于一个List，通常以中缀函数的形式调用它。</p>
<blockquote>
<p>ghci&gt; 4 `elem` [3,4,5,6] <br />
True <br />
ghci&gt; 10 `elem` [3,4,5,6] <br />
False </p>
</blockquote>
<p>List的Range功能。对于一个链表，需要的只是定义其</p>
<blockquote>
<p>[init, init + step_length ... last_val]</p>
</blockquote>
<ul>
<li>注意，在range中避免使用浮点数。</li>
</ul>
<p>同样，如果对于列表的末值不确定，可以采用无限列表。例如：</p>
<blockquote>
<p>[1,2 ...]
take 100 [1,2 ...] # -&gt; [1,2,3,4........., 100]</p>
</blockquote>
<p>这里就采用了惰性求值的模式，无限不意味着要求出来，可以确定性结果出来了在决定求值多少。</p>
<p>cycle函数返回一个无限的单次循环List</p>
<blockquote>
<p>ghci&gt; take 10 (cycle [1,2,3]) <br />
[1,2,3,1,2,3,1,2,3,1] </p>
</blockquote>
<p>repeat则是返回重复的无限列表。duplicate返回包含某个元素指定次数的列表。</p>
<p>定义某个集合：</p>
<blockquote>
<p>[ 2 * x | x &lt;- [1,2..10], x * 2 &gt;= 12 ]</p>
</blockquote>
<p>元素值，列表，条件</p></body></html>