<!DOCTYPE html><html><head><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>On_Multi_Agent_System</title></head><body><h3 id="multi-agent">构建自己的Multi-Agent系统</h3>
<hr />
<p>本科阶段接触过一些和Multi-Agent有关系的资料以及项目。我是一个极简主义者，我不喜欢一些重型开发框架，它们带来便利的同时，我们从学习成本与定制以及系统改善角度出发，也带来了不小的复杂度（Joel曾经说过的漏洞抽象问题）。框架是拿来复用的，类似于设计模式，框架是对于一类问题的解决方式的抽象模式。互联网飞速发展，开发互联网应用的当下，谁都在说MVC，或者MV*等等。基于这类模块组织方式出现的框架层出不穷，但是不同的框架却在可定制性与框架的结构性之间做权衡。</p>
<p>一个通用的框架，应对可能的开发需要提供的feature较多，但与此同时这样的框架在演化过程当中就会不可避免地面临框架不断复杂化，导致框架越来越“重”，甚至重构。最后往往是开发一个中小型项目不需要的许多功能，由于框架包的集成，从而在最后部署的时候也不得不将多余部分加入其中；另一种情形是框架的模块间独立性较差，那么在对框架的使用时，可能需要对框架实现进行深入地了解，甚至较大的改动。</p>
<p>一些设计得可扩展性较强的框架这方面受到的影响可能会小一点，比如将扩展作为plugin形式的支持热拔插的软件体系结构也不少。另一方面，如果给予程序员足够的自由，那么一个框架只需要定义正交的组件作为核心，而外部的扩展以及定制完全交由开发人员，重型框架面向的是构建大型应用的开发方，近年来出现的一些Ruby社区的开发人员由RoR转向较为简易的framework，比如Sinatra（结合Thin Server等组件），（个人曾用Sinatra以及active_record等搭建了简易的mvc框架）；再比如Javascript中类似Riots.js这样的微型框架，都是提供了最核心的（渲染，路由，事件注册）功能，而交由开发人员去定制。</p>
<p>其实二者各有利弊，在开发复杂性很高的系统时，自由的开发方式带来的是可维护性甚至于质量属性上的难以把握，对于小型系统又有写杀鸡焉用牛刀的意思。针对这个Multi-Agent系统，我预期实现的是一个直观的可配置，轻量级的Multi-Agent系统，对Agent能够采用更灵活的方式实现定制以及通信，方便建模，以及测试。</p>
<hr />
<p>下面来说说Multi-Agent系统，引自。</p>
<blockquote>
<p>Multi-Agent系统(MAS)是多个Agent组成的集合，其多个Agent成员之间相互协调，相互服务，共同完成一个任务。它的目标是将大而复杂的系统建设成小的、彼此互相通信和协调的，易于管理的系统。</p>
</blockquote>
<hr />
<blockquote>
<p>各Agent成员之间的活动是自治独立的，其自身的目标和行为不受其它Agent成员的限制，它们通过竞争和磋商等手段协商和解决相互之间的矛盾和冲突。MAS主要研究目的是通过多个Agent所组成的交互式团体来求解超出Agent个体能力的大规模复杂问题。</p>
</blockquote>
<hr />
<blockquote>
<p>MAS的关键问题是该系统中每个Agent功能的确定以及各Agent之间的协作，协商，交流。单个Agent的功能即该Agent的自主性，即该Agent所能完成的功能；Agent之间的协作即某个Agent将要完成的任务分配给其他Agent然后综合各Agent的结果将最后的结果输出给用户的过程；协商即Agent之间解决冲突并最后达到一致的过程。</p>
</blockquote>
<p>Agent是具有解决一定问题能力的个体单位。有人会问这与面向对象的区别在哪里，一般的面向对象中的对象通信停留在消息传递机制通信或者基于调用-返回，对象是被动的，而面向对象是在对数据以及其相关操作的封装上的抽象。相比之下，Agent系统中的agent是用于协同解决问题的，所以Agent处于更高的抽象层次上。Agent必须能够感知环境（根据环境变化而变化，有一定目标且对目标的实现有自己的决策以及行动）。</p>
<p>如此看来Agent的行动既有相对独立性，同时也有协作性。Agent也分为3种类型：</p>
<ul>
<li>
<p>被动式Agent，根据请求-响应机制进行通信以及执行任务完成一定任务</p>
</li>
<li>
<p>主动式Agent，有自己的目标，并且有能力将目标转化为一定的行动，与别的Agent进行主动的通信</p>
</li>
<li>
<p>复杂Agent，在主动式Agent基础上，有对于环境变化不断适应，不断学习的能力，有着更加高级的通信机制以及更复杂的行为</p>
</li>
</ul>
<p>多Agent理论分为3部分，多Agent系统框架，多Agent系统的建模以及应用，多Agent系统的正确性验证/测试。此次笔者目标是搭建一个多Agent系统的框架。</p>
<p>国际上对于多Agent系统进行规范化的组织是FIPA，有点像FIFA来着~
全称是：Foundation for Intelligent Physical Agents. 系统的结构我希望从其Specification上了解下。初步打算是搭建一个异步消息通信的agent简单框架，然后慢慢扩展，先不支持分布式，只是本地版。</p>
<p>期待后续。</p></body></html>