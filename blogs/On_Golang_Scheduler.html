<p>###Go的调度器</p>

<p>原文地址: <a href="http://http://morsmachine.dk/go-scheduler">http://http://morsmachine.dk/go-scheduler</a></p>

<p>By Daniel Morsing
翻译: Xifzop</p>

<p>简介：</p>

<blockquote>
  <p>Go 1.1版本中值得注意的新特性之一就是新的调度器，由Dmitry Vyukov贡献。新的调度器将Go程序的并行性能提升到了一个全新的高度，对此我想我该写点什么了。</p>
</blockquote>

<p>在这篇博客中说到的大部分内容都在<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit">original design doc</a>提到了，不得不说这是一篇挺综合性与技术性兼具的文档。</p>

<p>你需要对新的调度器有所了解的都在那篇设计文档里讲解了，但是这篇里面有图有真相，就可理解性来说这篇更被推荐。</p>

<hr />

<p>Golang的runtime到底需要一个什么样的调度器呢?</p>

<p>我们来仔细剖析新的调度器前，我们得了解下调度器存在的必要性 ---- 在操作系统能够为你提供线程调度的情况下，我们为什么还要自己去实现一个用户空间下的调度器?</p>

<p>POSIX标准的线程API是对既有的Unix进程模型的相当逻辑化的扩展，由此对线程的许多操作也继承自进程操作。线程有着他们自身的信号屏蔽字(signal mask)，可以进行调度，可以放到cgroups中，或者查询相关的资源。这些控制以及部分资源对Golang中的goroutine而言，不是必要的，而且当系统中的线程数超过10万时，不必要的负担就非常明显了。</p>

<p>另外一个问题在于，操作系统无法根据Golang所需要的底层模型选择与之相匹配的调度策略（可定制性..）.例如：</p>

<blockquote>
  <p>Golang的垃圾收集器规定：当进行垃圾收集的时候，所有的相关线程应当停止，同时内存数据必须保证一致性。这牵涉到等待一个正在执行的线程达到我们所需要以及可确定的内存一致状态。</p>
  
  <p>而对于一般情况下的操作系统级别的线程调度，由于执行的先后顺序不能确定，使得等待并确认所有的线程达到内存一致性状态是一件麻烦的事情。要是有了我们自己的调度器，那么这些就不会是问题，可达的内存一致性的点可以预先获得，并在最适合的时机停下来，完成垃圾收集工作，而此时最多就是等待花在当前在CPU上运行的线程上。</p>
</blockquote>

<p>####角色的模具</p>

<p>一般有三种常见的线程模型。</p>

<ul>
<li><p>N对1模型，这种模型一般是多个用户空间的线程映射到一个OS线程，这种线程模型的好处在于，可以进行快速的上下文切换，以及自定义的切换策略，但是不足之处也很明显，不能有效利用操作系统多核的优势。</p></li>
<li><p>1对1模型，这种模型下，一个用户空间的线程对应的就是一个OS的线程，这种线程模型能够有效利用OS多核优势，但是线程切换就要附加一定的开销，因为调度是由操作系统完成的，trap涉及到系统调用，核心态的来回切换比较耗时。</p></li>
<li><p>第三种模型，也是Golang所追求的之前二者的一个折衷 ---- M对N。若干个Goroutine被挂靠在若干个OS线程上，如果做法得当，你得到高上下文切换效率的同时，也能利用操作系统的多核优势。唯一不足的是应对可能不同额Goroutine间的协作情境，调度器的实现就变得复杂了。</p></li>
</ul>

<p>为了实现M对N模型，Golang的调度器采用了三种实体模型：</p>

<p><img src="http://morsmachine.dk/our-cast.jpg" alt="MPG entities for Golang Scheduler" /></p>

<ul>
<li><p>三角形代表了OS线程，这是由OS直接进行调度执行的线程，与POSIX标准线程差不多。在runtime代码中，M指的是Machine.</p></li>
<li><p>圆圈代表的是一个Goroutine。其数据结构是一个栈，指令指针（指向预执行的地址）以及对Goroutine调度所必须的一些信息，例如阻塞的通道（Channel）。</p></li>
<li><p>矩形的P代表调度的当前上下文。你可以将其视为本地版本的Golang执行调度器，工作在单线程上。这是实现M:N线程模型很重要的一环。P全称是Processor。后面会讲的更深入一些。</p></li>
</ul>

<p><img src="http://morsmachine.dk/in-motion.jpg" alt="example1" /></p>

<p>如图，我们可以看到有两个线程（M），每个线程持有一个上下文（P），每个上下文中执行一个Goroutine（G）. 线程需要有上下文才能执行Goroutine。</p>

<p>Context(P)的个数在初始化阶段被赋给了环境变量<strong>GOMAXPROCS</strong>. 或者可以通过运行时的函数<strong>GOMAXPROCS()</strong>进行设置。但是一般情况下这个变量的值在程序运行的全过程中是不会发生变化的。</p>

<p>上下文P的数量固定意味着在一个时间点最多有指定数目个P在执行Golang的程序。我们可以利用这个将Go程序执行的任务分担到当前计算机支持的合理线程数，比如四核的就有四个线程。</p>

<p>被上了灰色的Goroutine不在执行期间，但是处于就绪状态。它们被组织成一个个列表中，被称为运行队列（runqueue）。在Goroutine语句执行的时候，其余的Goroutine则被添加至runqueue末尾。当到达一个调度点的时候（到达某个调度条件），其便从队列中弹出一个Goroutine，设置栈以及指令指针，并且继续执行。</p>

<p>为了避免互斥所的争用，每个Processor持有一个本地的runqueue。前一个版本的Golang只有一个全局的runqueue，并且通过一个mutex变量对其进行互斥加锁保护，这样一来在运行中线程往往被阻塞以等待资源锁的释放。这样一来，你若想在一个32核的机器上发挥出其应用的性能，那么只可能是个天方夜谭了。</p>

<p>一般情况下，只要所有的Processor都处在调度忙的状态，调度器就能正常工作。当然也有些例外情况。</p>

<p>#####你准备调用谁?</p>

<p>你可能想知道，到底为什么需要Context(Processor)?我们直接把runqueue挂到线程上不就好了么? 不不不。有Context的原因是，如果某个线程由于某个原因而将被阻塞一段时间，那么可以将队列转接到别的processor上。</p>

<p>阻塞情况的一个例子，就是我们在执行的过程当中需要完成一次系统调用。一个线程不能既等待系统调用，同时又执行代码。因此我们的做法是，将与系统调用相关的Goroutine交付给某个专门负责系统调用的线程，而Processor这边专门进行别的调度。如图：</p>

<p><img src="http://morsmachine.dk/syscall.jpg" alt="example2" /></p>

<p>图中我们可以看到，M0的线程放弃了context，而挂靠到M1线程上，由M0去等待完成G0的系统调用执行。调度器会保证有充足的线程提供给context。M1线程的来源，可能是为了系统调用不阻塞原先的context而被生成的，或者来自某个线程缓存中（Thread cache）。那个持有申请系统调用的goroutine的线程会继续维护那个goroutine。</p>

<p>系统调用返回时，维护单个goroutine的线程会想方设法获得一个context的帮助，以继续运行那个goroutine，常见的模式是其从别的线程那儿“偷得”一个context。如果context获取的尝试失败，那么其会将goroutine挂到全局的runqueue上去，并且将自己挂靠到线程缓存尾部，并进入睡眠状态。</p>

<p>这里提到的全局runqueue是当某个context执行完自己本地的runqueue（即runqueue为空时），才从全局runqueue获得goroutine，并且执行之。context也会周期性地check全局队列，以免队列中的goroutine被饿死。这也是为什么在GOMAXPROCS时仍然支持多线程。</p>

<p>#####Stealing Work
打破调度器以及系统稳定执行状态的另外一种情况是：当某个context执行完自己该执行的那部分goroutine时，特别是在多个context的runqueue上挂载的任务数或者任务执行耗时不一致时，此时会产生资源的浪费，（有活不干）。为了提高潜在执行效率，执行完本地任务的goroutine，会去执行全局的runqueue，还没有的话就去执行其他context的任务。</p>

<p><img src="http://morsmachine.dk/steal.jpg" alt="example3" /></p>

<p>当一个context执行完本地任务之后，其会从另一个context中获得1/2的执行任务，以此保证执行资源的相对均衡分配。</p>

<p>当然关于调度器，我们还有很多细节没有提及，比如cgo线程，LockOSThread()函数体，以及与Network Poller的集成。这些不属于本篇的内容，但是仍然很值得学习。相关的会有后续更新。在Golang的库中有趣构建模式还有很多，等待你去发现。</p>
