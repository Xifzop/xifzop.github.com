<!DOCTYPE html><html><head><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>On_Behavior</title></head><body><h3 id="_1">行为型模式</h3>
<ul>
<li>责任链模式</li>
<li>命令模式</li>
<li>解释器模式</li>
<li>迭代器模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>观察者模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>模板方法模式</li>
<li>访问者模式</li>
</ul>
<p>行为型模式系列用来分类定义对象之间的常用通信模式并加以实现。行为型模式，涉及到算法和对象间的职责分配，不仅描述对象或类的模式，还描述它们之间的通信方式，刻划了运行时难以跟踪的复杂的控制流，通过行为型模式的采用，可以简化面临系统控制流一些常见场景的设计，将更多的设计关注点转到对象间的关系上来。由此可见设计模式的三个不同的系列彼此是相辅相成的，面对不同的侧重点。同时分类之间的使用可以说是正交的，由此不得不佩服GoF敏锐的洞察力。</p>
<p>常见的11种行为型模式在上面列出来了。我们接下来一个个看。</p>
<h5 id="chain-of-responsibility-pattern">Chain of Responsibility Pattern</h5>
<p>先来看一下，Wiki中的定义：</p>
<blockquote>
<p>在面向对象程式设计里, 责任链模式是一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。</p>
</blockquote>
<p>通常这种处理方式类似于总线模式，在某个消息传递的过程当中，如果中间某个处理者完成了对于该信息的处理，则不再往责任链模式后面部分传递。我们可以通过这种模式，动态地添加处理者函数。在Tomcat中的filter以及Struts的pattern matching中都运用了类似的模式。使用这种模式需要注意的是有些处理者的先后顺序需要区分清楚，否则由于被某一处理者接受后不再往后传，很可能达不到预期的效果。例如，有个页面请求的filter，配置如下：</p>
<blockquote>
<p>accept all
reject xxx</p>
</blockquote>
<p>原意是处理除了xxx之外请求，但是由于先后顺序的问题，使得xxx也被纳入处理范围。这是在逻辑上需要注意的一点。第二点是消息格式（消息的数据结构）必须被所有处理者所熟知或者共享，在SOA中，不同的web service在处理请求时候使用到了平台实现无关的xml格式以及相对应的格式定义，使得service之间除了数据上的耦合之外，灵活性非常强，但是共享数据结构，使得需要额外的解析工作，数据结构的独立性也需要考虑。（SOA是人家已经完成了XSD的定义，有了较为完整消息格式定义）</p>
<p><img alt="Chain of Responsibility" src="file:///Users/tonie/Sites/xifzop.github.com/blogs/../pics/chain_of_resp.gif" /></p>
<p>回过头来我们看到在编程语言中的实现，可以有几种方案：</p>
<blockquote>
<ul>
<li>将处理者组织成一个链表，并且通过处理者如果有责任则处理否则对下一个处理者进行递归调用的方式来实现，这样的方法达成了责任链的意图，然而面临的问题在于如果递归层次过深，是个比较大的问题。有点程序语言支持尾递归，则可以免除这种忧虑</li>
<li>将处理者置入一个链表中，专门有一个对象对链表进行管理，利用循环遍历链表完成传递。在传递的过程中，根据对象的返回情况决定是否继续传递。如果面对较高的平均遍历深度调用，可以对无冲突的处理者的先后顺序进行动态调整</li>
</ul>
</blockquote>
<p>有个不纯粹的责任链模式的例子就是在2级DOM模型中的事件传递机制，DOM树的每个符合要求的遍历路径上的节点都可以看做是一个处理者，详情自戳<a href="http://www.w3school.com.cn/xmldom/prop_event_bubbles.asp">此地址</a>。</p>
<p>责任链模式使得在面对事件或者消息的处理时，系统的可配置性以及灵活性更强。</p>
<h5 id="command-pattern">Command Pattern</h5>
<p>对于命令模式，GoF给出的定义是：</p>
<blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 </p>
</blockquote>
<p>先上类图:</p>
<p><img alt="command pattern diagram" src="file:///Users/tonie/Sites/xifzop.github.com/blogs/../pics/command_pattern.png" /></p>
<p>命令模式一个很大的应用场景就是将系统的行为封装之后，还需要支持对于操作流程的追踪或者回溯（undo）。我们可以将数据库中的日志记录以及日志恢复看做是命令模式的一个变体，在数据库中，当一个事务(Transaction)没有被完成而数据库由于某些不确定性因素而导致系统崩溃。重启数据库时，数据库需要有能力对崩溃前的数据情况进行恢复，而根据的是更新的日志。同样地，在命令模式当中，由Invoker对command进行记录以及执行；而Receiver作为被操作的对象，提供可操作的接口，在ConcreteCommand中被按照一定需要进行使用。最后由客户端发送相应的请求，而无需关心命令调用的细节，以及可能的操作追踪，或者undo以及redo之类的操作。</p>
<p>这样的模式，通过封装实现调用者和具体的执行者之间的解耦。命令模式可以将一定粒度的操作封装起来，当然设计模式中的任何模式，都需要一定粒度的封装，如果对于系统实现中一些很简短的操作，或者几个函数可以搞定的事情，非要套用命令模式，那么是很不值得的，毕竟任何程度的抽象都是在一定“粒度”的背景环境下的。高级语言是高层次的抽象，可以高效地帮你完成很多任务，但是对于任务细节的细粒度的调整，你还是要深入底层，了解背后的机制，这与易用性是相悖的；再比如C++中对于内存管理（当然也有可以加入的GC，这里不谈），对象的回收以及释放是授权给开发者的，这对于内存回收来说很细粒度的控制，保证内容及时回收不用的内存，而在Java等有GC的语言当中，由于GC的维护以及运行需要一定开销，因而只能进行阶段性（Periodic）的内存垃圾回收，这使得开发者在大多数情况下不需要关心内存的释放以及内存泄露等行为，更关注于开发逻辑。后者提供了一定的内存管理的一层抽象，但是当遇到性能瓶颈时，又需要了解其背后的GC机制，才能更好地提升；再比如，现在流行很多框架，框架其实是将开发某一类应用的可重复性地过程或者结构，抽象出来，而细节实现以及如何组织由框架的使用方来决定（业务处理，具体实现），因而框架是作为一个半成品而存在的。使用一个框架，我们不仅需要学习成本，同时如何更好地提升开发应用的性能，我们可能也需要额外的理解框架背后的实现细节从而达到目的，这些都是低于框架所处粒度层面的细节，我们无法避免这些细节。</p>
<p>命令模式是对于行为细节的封装，而工厂模式，我们则可以看做是对于创建行为的封装，通过将创建行为委托给子类去关心，而对于调用方提供一个统一的创建对象接口，隐藏了实现，同时也利于扩展。</p>
<p>命令模式的一个实现:</p>
<pre><code>#! /usr/bin/env python

from util import *

''' Cmd super class supporting `do` and `undo` operation '''
class Command(object):

    @method_not_implemented
    def do(self, *args):
        pass

    @method_not_implemented
    def undo(self, *args):
        pass

    def undoable(self):
        return True

    ''' in order to support logging '''
    def desc(self):
        return "No description yet.\n"

    ''' CommandList to record the operation list '''
    class CommandList(list):

        def __iadd__(self, val):
            self.append(val)
            return self

class CommandCategory(dict):
    pass

''' Invoker to manager and invoke commands '''
class CommandManager(object):

    def __init__(self):
        self._hist = CommandList()
        self._redo = CommandList()
        self._cmds = CommandCategory()

    def reg(self, cmd_name, cmd):
        self._cmds[cmd_name] = cmd

    def rmv(self, cmd_name):
        del self._cmds[cmd_name]

    def exc(self, cmd_name, *args):
        if cmd_name in self._cmds:
            cmd = self._cmds[cmd_name]
            if cmd.undoable():
                self._hist += cmd
            return cmd.do(*args)
        else:
            return None

    def roll_back(self, *args):
        if len(self._hist) &gt; 0:
            cmd = self._hist.pop()
            cmd.undo(*args)
        self._redo += cmd
        return True
    else:
        return False

    def redo(self, *args):
        if len(self._redo) &gt; 0:
            cmd = self._redo.pop()
            self._hist += cmd
            return cmd.do(*args)
        else:
            return None

    ''' not gonna record the undoable action '''
    def log(self, logger):
        if 'write' in dir(logger):
            for cmd in self._hist:
                logger.write(cmd.desc())
        else:
            raise Exception("Logger %s is not writable." % logger)


'''
    Here is the demo object as Receiver.
    The receivers in practical code may be variant.
'''
class Light(object):

    def turn_on(self, *args):
        print 'light turned on.'

    def turn_off(self, *args):
        print 'light turned off.'

'''
    Command for light operation
'''
class TurnOnCommand(Command):

    def do(self, *args):
        light = args[0]
        light.turn_on()

    def undo(self, *args):
        light = args[0]
        light.turn_off()


class TurnOffCommand(Command):

    def do(self, *args):
        light = args[0]
        light.turn_off()

    def undo(self, *args):
        light = args[0]
        light.turn_on()


class Client(object):

    def __init__(self, mnger):
        self._mnger = mnger

    def exec_some_task(self, *args):
        self._mnger.exc('On', *args)
        self._mnger.exc('Off', *args)
        self._mnger.roll_back(*args)
        self._mnger.redo(*args)


if __name__ == '__main__':
    cmd_manager = CommandManager()
    light = Light()
    cmd_manager.reg('On', TurnOnCommand())
    cmd_manager.reg('Off', TurnOffCommand())
    client = Client(cmd_manager)
    client.exec_some_task(light)

    with open('demo.log', 'w') as logger:
        cmd_manager.log(logger)
</code></pre>
<h5 id="interpreter-pattern">Interpreter Pattern</h5>
<p>解释器模式</p>
<h5 id="iterator-pattern">Iterator Pattern</h5>
<p>迭代器模式</p></body></html>