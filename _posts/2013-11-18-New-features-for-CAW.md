---
layout: post
title: 在CAW中添加自动重启功能
---


##{{page.title}}
***
***2:41 下午 星期一, 十一月 18, 2013***

***
前一段搭建的简易Web App开发框架[CAW](详见另外一篇CAW框架的介绍)。
在使用CAW开发的过程中，由于对于client request路由，数据库配置，以及处理特定请求调用的处理方法这些都是在CAW中服务器启动一开始进行初始化的，所以在每次对于与这些相关的文件进行修改之后，总是要手动重启服务器，总让人觉得很麻烦，于是借着之前在开发别的项目的时候的服务器的使用经验，个人觉得说服务器应当能自动检测到配置或者初始化所需的注册文件的变化，并且进行相应的重启。当然，这只是第一阶段的想法，第二阶段希望能实现平滑地重新加载服务器最新的配置，也就是不让CAW中服务器进程终止的情况下，对CAW相应的模块进行部分重新加载，也就是“热加载”，有点类似JVM中动态加载类这样的任务，获得运行时带来的灵活性。这样的话，每次服务器总能反映出最新的配置变化，给开发能省省心。

第一个版本自然是要从最简单的功能。

下面这段可以跳过。

---
关于这一点，之前有过一两个失败的项目经历（和MAS金融建模仿真相关的），就是由于前期对项目要开发的系统的总体结构没有一个总体的把握，或者说没有先搭建出一个系统的“骨架”出来，使得我们前期把过多的经历花在了对于领域知识的学习，以及领域模型的分析上面。当然，这没有错，错在没有一个结构化的框架给我们的领域问题的考虑设定一个边界，很有可能导致过度分析。金融之类领域的问题分析，复杂性都是很大的，模型，模型因子，公式，概念等等之间错综复杂，没有通过约定（文档等）以及系统框架（系统原型）边界；另一方面，项目开发没有严格遵循以及实施一定的时间管理，进度跟踪，这些因素汇集起来，很容易导致开发过程的混乱。尽管是这么说的，但是个人目前比较倾向的并不是自顶向下的开发，而是自顶/自底向中间的开发，一方面，自顶向下是定义出系统的总体结构方案，第二方面，自底向上，是将业务细节作为feature-plugin，不断注入已有的系统框架中，而原有的系统的框架可以不断地完善。

---

让服务器在配置更新时进行自动地重新加载，主要思路就是利用多线程，有一个monitor线程对指定的文件系统目录进行检测，一旦发现有配置文件或者初始化所需的代码更新，则中断服务器线程，并新建立一个服务器线程，完成重启动。

想法简单，现实却有不少约束。

由于[CAW]最早搭建的win7的ruby-1.9.3环境下。这就要面临几个问题：

+ 个人选择的MRI版本的ruby，而MRI版本的ruby一个比较大的问题在于，ruby使用的是伪线程（关于这个的讨论参见[concurrency-is-a-myth-in-ruby]。具体就是MRI实现的ruby中，实现的并不是真正意义上的多线程机制：
	+ 在ruby-1.8版本下，是利用单个线程模拟多线程，在这种情况下，ruby意义上的多线程只对于不同线程间有io阻塞的任务线程而言，效果比较明显。而对于cpu计算密集型的线程则没有什么明显的效率提升，而且由于实际是单线程，所以对于multi-core的机器，基本发挥不出多线程应有的优势，而且对于这种情况下的多线程，反而不如单线程执行的效率高，因为还要考虑到ruby内部实现中为了模拟多线程的线程进行系统调度的代价。
	+ 在ruby-1.9版本中，看起来是实现多线程了，但是实际上，ruby解释器中还存在着全局解释器锁[GIL]。同样，PYTHON解释器中也有类似的实现。在运行多线程时，[GIL]成为一个瓶颈。GIL对于在同一解释器中的线程，进行线程安全的保护机制，所以在同一时间内只有一个线程能够执行，这对于单核是没有很大区别的，关键是现在进入了“多核时代”，所以对于ruby的MRI实现而言，即便在1.9版本中实现了多线程，但是由于GIL的缘故，多线程也无法发挥出很好的多线程多核优势。
	+ 2.0方面还没有研究。
	+ 所幸的是，对于ruby的另外的实现，例如jruby以及rubinius中，对于真正意义上的多线程的是有保障的，jruby解释成jvm字节码，可以藉由JVM发挥出多核优势；而后者还没有研究。
+ 其次，就是windows下的多线程机制，多进程机制和Linux是有许多不同的，这也让我不太习惯，当然，完成这版windows的，linux就比较好办了。

完成这项任务，需要一个文件系统监视器的实现（在发生特定文件目录下变化时，利用callback function（block）通知服务器），以及完成monitor与服务器之间的通信（monitor与服务器处于不同的任务调度单位中（线程或者进程））。

关于文件系统监视器，在ruby中，我选择的是gem包[fssm]，当然也有另外一个gem包：[listen]。
fssm似乎对jruby的支持不是太好，还没有亲测，listen貌似还行，但是其利用轮询的机制效率比较低。由于ruby中对于多线程的支持，让人望而却步，而且在win下使用多线程来模拟一个monitor线程对于一个服务器进程的通信，貌似是不行的，一次只能执行某一个线程（要么monitor，要么服务器）估计又是GIL导致的。所以最终，我还是选择了多进程来完成这项任务。

在最开始启动服务器时，启动一个monitor进程，对当前项目文件目录进行监控，发生变化时，就向服务器进行发送中断信号。这些在描述上是可行的。但是具体情况呢？

ruby下，利用spawn完成新进程的创建，具体可以参见ruby的doc，里面有完整的对于Process.spawn的描述。

对于fssm，如何定义callback function在[fssm]的readme.md有完整demo。
fssm的monitor进程开始运行，服务器进程开始运行。关键在于如何给服务器进程发送信号，在ruby中有默认的Process.kill，可以发送posix的信号，但是对于win环境下，这个函数貌似支持不是太好，亲测只有INT这个信号可用，而根据报错，看出来其还是遵循POSIX的信号规范，所以无奈就不适用，转向使用ruby中调用shell命令，一般有如下三种方式：

+ \`your command\`
+ exec \`your command\`
+ system \`your command\`

在win下，不是用kill命令，而是采用taskkill命令，“taskkill /PID your-pid /T /F”

/T是用来终止属于该进程的进程子树的，而/F是强制终止，如果其还有父进程的话，也强制终止。

在ruby中，每次运行一个新的shell命令，总是使用新的console进程，而该命令进程会作为该console的子进程执行，所以要直接对该命令进程（对应于我们需要的服务器进程）发送中断命令的话，如果不加/F那么将失效，由于其属于新的console进程。而增加/F关键字，由于新的console属于当前的console，所以发送的信号同样将会使得当前的console进程终止，这不是我们想要的结果。我们需要做的是，将当前执行的命令detach到新的console中去, 这样对于服务器进程的终止就不会出现我们不希望出现的情况了。至于更深入的一些情况，我没有进行深入分析，比如说给一个irb进程发送一个INT信号，为什么只有在win下是无效的等等。

通过ruby进行进程间通信，这个监视部分文件系统并且通知服务器重新载入的new feature就完成了，已经添加到[CAW]的最新版本中去了。

[CAW]: https://github.com/Xifzop/CAW "Web App Framework CAW"
[concurrency-is-a-myth-in-ruby]: http://www.igvita.com/2008/11/13/concurrency-is-a-myth-in-ruby/ "Ig"
[GIL]: http://en.wikipedia.org/wiki/Global_Interpreter_Lock "Global Interpreter Lock"
[fssm]: https://github.com/ttilley/fssm "文件系统监控"
[listen]: https://github.com/guard/listen "文件系统监控"